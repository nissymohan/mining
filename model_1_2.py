# -*- coding: utf-8 -*-
"""MODEL 1.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LL09jX1uMG1jf2TUjs6vW-ABnUY-lDqZ
"""

import pandas as pd

df=pd.read_csv('/content/cleaned_discretized_tourism_data.csv')

display(df.head())

"""# **Label-Encoding**"""

from sklearn.preprocessing import LabelEncoder

# List of columns to encode
columns_to_encode = ['Country', 'VisitMode', 'AttractionType', 'Attraction']

# Create a dictionary to store the encoders for future use if needed
encoders = {}

# Apply Label Encoding to each specified column
for column in columns_to_encode:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    encoders[column] = le  # Store the encoder for each column

# Display the transformed DataFrame
print("Encoded DataFrame:")
display(df.head())

# Optionally, save the encoders for decoding later
import pickle
with open('label_encoders2.pkl', 'wb') as f:
    pickle.dump(encoders, f)

"""# **One-hot Encoding for country's**"""

encoders

import pandas as pd
from sklearn.preprocessing import OneHotEncoder

# Assuming df already contains the data
# Step 1: Initialize the OneHotEncoder for the 'Country' column
onehot_encoder = OneHotEncoder(sparse_output=False)

# Step 2: Fit and transform the 'Country' column
country_encoded = onehot_encoder.fit_transform(df[['Country']])

# Step 3: Convert the one-hot encoded array to a list format for each row
df['Country_OneHot'] = country_encoded.tolist()

# Step 4: Display the DataFrame with the new column
print("DataFrame with One-Hot Encoded 'Country':")
display(df[['Country', 'Country_OneHot']].head())

# Save the fitted encoder to a pickle file
with open('country_onehot_encoder2.pkl', 'wb') as file:
    pickle.dump(onehot_encoder, file)

print("OneHotEncoder has been saved successfully!")

print(onehot_encoder)

"""# **Creating new features "VisitMode_Country", "VisitMode_VisitMonth" from association rule insights**"""

import numpy as np

# Step 1: Ensure 'VisitMode' and 'VisitMonth' are integers
df['VisitMode'] = df['VisitMode'].astype(int)
df['VisitMonth'] = df['VisitMonth'].astype(int)

# Step 2: Create the interaction feature 'VisitMode_VisitMonth'
df['VisitMode_VisitMonth'] = df['VisitMode'] * df['VisitMonth']

# Step 3: Ensure 'Country_OneHot' is an array for vectorized operations
df['Country_OneHot'] = df['Country_OneHot'].apply(np.array)

# Step 4: Generate the interaction feature 'VisitMode_Country'
df['VisitMode_Country'] = df.apply(
    lambda row: row['VisitMode'] * row['Country_OneHot'], axis=1
)

# Display the new interaction features
print("DataFrame with Interaction Features:")
display(df[['VisitMode_VisitMonth', 'VisitMode_Country']].head())

"""# **Models**"""

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import pickle

# Assuming df already contains all the necessary preprocessing done above
# List of features and target
X_columns = ['AttractionType', 'Country_OneHot', 'VisitMode', 'VisitMonth',
             'VisitMode_VisitMonth', 'VisitMode_Country']
y_column = 'Attraction'

# Step 1: Prepare Data
# Convert 'Country_OneHot' and 'VisitMode_Country' columns from lists to arrays for model input
df['Country_OneHot'] = df['Country_OneHot'].apply(lambda x: np.array(x))
df['VisitMode_Country'] = df['VisitMode_Country'].apply(lambda x: np.array(x))

# Step 2: Create models for each 'AttractionType'
models = {}

# Iterate over each unique AttractionType to create separate models
for attraction_type in df['AttractionType'].unique():
    # Filter the DataFrame for the current attraction type
    df_filtered = df[df['AttractionType'] == attraction_type]

    # Extract features (X) and target (y)
    X = np.array([
        np.hstack([row['Country_OneHot'], row['VisitMode'], row['VisitMonth'],
                   row['VisitMode_VisitMonth'], row['VisitMode_Country']])
        for _, row in df_filtered.iterrows()
    ])
    y = df_filtered[y_column].values

    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize and train the RandomForestClassifier
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Evaluate the model
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print(f"Model accuracy for AttractionType '{attraction_type}': {accuracy:.2f}")

    # Store the trained model in the dictionary
    models[attraction_type] = model

# Step 3: Save the models using pickle
with open('attraction_models2.pkl', 'wb') as file:
    pickle.dump(models, file)

print("All models have been trained and saved successfully!")

print(models)

with open('label_encoders2.pkl', 'rb') as f:
    encoders = pickle.load(f)

encoders['Attraction'].classes_

import numpy as np
import pandas as pd
import pickle
from sklearn.preprocessing import LabelEncoder

# Load the saved label encoders and the one-hot encoder
with open('label_encoders2.pkl', 'rb') as f:
    encoders = pickle.load(f)

with open('country_onehot_encoder2.pkl', 'rb') as f:
    country_onehot_encoder = pickle.load(f)

# Load the pre-trained models
with open('attraction_models2.pkl', 'rb') as f:
    models = pickle.load(f)

def predict_top_3_attractions(country, visit_mode, visit_month, attraction_type):
    """
    Predict the top-3 attractions based on the given inputs.
    """
    # Step 1: Encode the inputs using the loaded encoders
    country_encoded = encoders['Country'].transform([country])[0]
    visit_mode_encoded = encoders['VisitMode'].transform([visit_mode])[0]
    attraction_type_encoded = encoders['AttractionType'].transform([attraction_type])[0]

    # Step 2: One-hot encode the country using the saved OneHotEncoder
    # Ensure input is a DataFrame with the correct column name
    country_df = pd.DataFrame([[country_encoded]], columns=['Country'])
    country_onehot = country_onehot_encoder.transform(country_df).flatten()

    # Step 3: Generate the interaction features
    visit_mode_visit_month = visit_mode_encoded * visit_month
    visit_mode_country = visit_mode_encoded * country_onehot

    # Step 4: Prepare the input feature vector
    input_features = np.hstack([
        country_onehot,
        [visit_mode_encoded],
        [visit_month],
        [visit_mode_visit_month],
        visit_mode_country
    ]).reshape(1, -1)

    # Step 5: Load the model corresponding to the attraction type
    model = models.get(attraction_type_encoded)
    if model is None:
        raise ValueError(f"No model found for AttractionType '{attraction_type}'")

    # Step 6: Make predictions
    predictions = model.predict_proba(input_features)

    # Get the top-3 predictions based on probabilities
    top_3_indices = np.argsort(predictions[0])[-3:][::-1]
    top_3_attraction_encoded = model.classes_[top_3_indices]

    # Step 7: Inverse transform the encoded attraction labels to get the original names
    top_3_attractions = encoders['Attraction'].inverse_transform(top_3_attraction_encoded)

    return top_3_attractions

# Example usage
country = "United Kingdom"
visit_mode = "Couples"
visit_month = 5
attraction_type = "Historical & Cultural"

top_3_attractions = predict_top_3_attractions(country, visit_mode, visit_month, attraction_type)
print("Top-3 Attractions:", top_3_attractions)