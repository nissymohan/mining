# -*- coding: utf-8 -*-
"""MODEL 3.2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oLRdfVNwomJ3cajWMVX1H4gPVUOhG26O
"""

import pandas as pd
df=pd.read_csv('/content/cleaned_discretized_tourism_data.csv')

print(df.head())

import pandas as pd
from sklearn.preprocessing import LabelEncoder
import pickle

# Assuming the data is already loaded into df
categorical_columns = ['Country', 'VisitMode', 'AttractionType', 'Attraction']

# Dictionary to store the encoders for each column
label_encoders = {}

# Encode each categorical column
for column in categorical_columns:
    le = LabelEncoder()
    df[column] = le.fit_transform(df[column])
    label_encoders[column] = le

print(df.head())
# Save the encoders to a pickle file
with open('label_encode-task3.pkl', 'wb') as file:
    pickle.dump(label_encoders, file)

print("Encoding complete and saved to 'label_encode-task3.pkl'")

import pandas as pd
from sklearn.preprocessing import OneHotEncoder
import pickle

# Assuming the data is already loaded into df
country_encoder = OneHotEncoder(sparse_output=False)
country_encoded = country_encoder.fit_transform(df[['Country']])

# Convert the one-hot encoded result into a DataFrame
country_encoded_df = pd.DataFrame(country_encoded, columns=[f'Country_{i}' for i in range(country_encoded.shape[1])])

# Add the one-hot encoded column as 'Country_OneHot' to the original DataFrame
df['Country_OneHot'] = country_encoded_df.values.tolist()

# Save the OneHotEncoder for future use
with open('onehot_encode_country-task3.pkl', 'wb') as file:
    pickle.dump(country_encoder, file)

print(df[['Country', 'Country_OneHot']].head())
print("One-hot encoding complete and saved to 'onehot_encode_country-task3.pkl'")

import pandas as pd
import numpy as np

# Assuming the DataFrame 'df' already contains the encoded columns and one-hot encoded 'Country_OneHot'

# Step 1: Create the interaction feature 'VisitMode_AttractionType' by multiplying the two integer-encoded columns
df['VisitMode_AttractionType'] = df['VisitMode'] * df['AttractionType']

# Step 2: Ensure 'Country_OneHot' is an array for vectorized operations
df['Country_OneHot'] = df['Country_OneHot'].apply(np.array)

# Step 3: Generate the interaction feature 'VisitMode_Country'
df['VisitMode_Country'] = df.apply(
    lambda row: row['VisitMode'] * row['Country_OneHot'], axis=1
)

# Display the updated DataFrame with the new interaction features
print("Interaction features created successfully!")
print(df[['VisitMode_AttractionType', 'VisitMode_Country']].head())

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
import pickle

# Assuming 'df' contains all the required encoded features and interaction columns

# Dictionary to store models and their accuracies
models = {}
accuracies = {}

# List of unique attractions
unique_attractions = df['Attraction'].unique()

# Train a separate model for each attraction and calculate accuracy
for attraction in unique_attractions:
    # Step 1: Filter the dataset for the current attraction
    df_filtered = df[df['Attraction'] == attraction]

    # Step 2: Prepare feature matrix X
    X = np.array([
        np.hstack([
            row['Country_OneHot'],
            [row['VisitMode']],
            [row['AttractionType']],
            [row['VisitMode_AttractionType']],
            row['VisitMode_Country']
        ])
        for _, row in df_filtered.iterrows()
    ])

    # Step 3: Prepare target variable y
    y = df_filtered['VisitMonth'].values

    # Step 4: Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Step 5: Train the RandomForest model
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Step 6: Make predictions on the test set
    y_pred = model.predict(X_test)

    # Step 7: Calculate accuracy
    accuracy = accuracy_score(y_test, y_pred)
    accuracies[attraction] = accuracy
    print(f"Accuracy for attraction '{attraction}': {accuracy:.2f}")

    # Step 8: Store the trained model in the dictionary
    models[attraction] = model

# Save the models dictionary to a pickle file for future use
with open('random_forest_models_task3.pkl', 'wb') as file:
    pickle.dump(models, file)

print("\nModels trained and saved successfully for each attraction!")

import numpy as np
import pandas as pd
import pickle
from sklearn.ensemble import RandomForestClassifier

def predict_top3_visit_months(country, visit_mode, attraction_type, attraction):
    # Load the saved label encoders
    with open('label_encode-task3.pkl', 'rb') as f:
        encoders3 = pickle.load(f)

    # Load the one-hot encoder for country
    with open('onehot_encode_country-task3.pkl', 'rb') as f:
        country_onehot_encoder3 = pickle.load(f)

    # Load the pre-trained models
    with open('random_forest_models_task3.pkl', 'rb') as f:
        models3_2 = pickle.load(f)

    # Step 1: Encode the input features using the label encoders
    encoded_country = encoders3['Country'].transform([country])[0]
    encoded_visit_mode = encoders3['VisitMode'].transform([visit_mode])[0]
    encoded_attraction_type = encoders3['AttractionType'].transform([attraction_type])[0]
    encoded_attraction = encoders3['Attraction'].transform([attraction])[0]

    # Step 2: One-hot encode the country (ensure it's a DataFrame)
    country_onehot = country_onehot_encoder3.transform(pd.DataFrame([[encoded_country]], columns=['Country'])).flatten()

    # Step 3: Create interaction features
    visit_mode_attraction_type = encoded_visit_mode * encoded_attraction_type
    visit_mode_country = encoded_visit_mode * country_onehot

    # Step 4: Prepare the feature vector for prediction
    X = np.hstack([
        country_onehot,
        [encoded_visit_mode],
        [encoded_attraction_type],
        [visit_mode_attraction_type],
        visit_mode_country
    ]).reshape(1, -1)  # Reshape to match the expected input format

    # Step 5: Predict using the pre-trained model for the given attraction
    if encoded_attraction in models3_2:
        model = models3_2[encoded_attraction]
        predicted_months = model.predict_proba(X)[0]

        # Get the top-3 months with the highest probabilities
        top3_indices = np.argsort(predicted_months)[-3:][::-1]  # Sort in descending order
        top3_months = [i + 1 for i in top3_indices]  # Convert indices to months (1-12)

        #print(f"Top-3 visit months for '{attraction}' are: {top3_months}")
        return top3_months
    else:
        print(f"No model found for attraction: '{attraction}'")
        return []

# Example usage
country = "United Kingdom"
visit_mode = "Couples"
attraction_type = "Historical & Cultural"
attraction = "Tanah Lot Temple"

top3_months = predict_top3_visit_months(country, visit_mode, attraction_type, attraction)
print(f"Top-3 visit months for '{attraction}' are: {top3_months}")