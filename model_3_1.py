# -*- coding: utf-8 -*-
"""MODEL 3.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fj96NG1hYfze-_dn5KeQoGpRM7JyJZpm

# **Model-3.1**
"""

import pandas as pd
import numpy as np
import pickle
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score

# Load and preprocess the dataset
file_path = '/content/cleaned_discretized_tourism_data.csv'  # Update this path
data = pd.read_csv(file_path)

# Select and trim relevant columns
data = data[['Country', 'VisitMode', 'AttractionType', 'Attraction']]
data['Country'] = data['Country'].str.strip()
data['VisitMode'] = data['VisitMode'].str.strip()
data['AttractionType'] = data['AttractionType'].str.strip()
data['Attraction'] = data['Attraction'].str.strip()

# Fit the label encoders on the entire dataset
label_encoders = {}
for column in ['Country', 'VisitMode', 'AttractionType', 'Attraction']:
    le = LabelEncoder()
    le.fit(data[column])
    data[column] = le.transform(data[column])
    label_encoders[column] = le

# Save the label encoders
with open('label_encoders3.pkl', 'wb') as f:
    pickle.dump(label_encoders, f)
print("Label encoders saved as 'label_encoders.pkl'.")

# Preprocess attractions by AttractionType
attractions_dict = {}
for attraction_type in data['AttractionType'].unique():
    # Filter attractions for the current AttractionType
    type_data = data[data['AttractionType'] == attraction_type]
    attractions = type_data['Attraction'].unique()
    attractions_dict[attraction_type] = attractions

# Save the preprocessed attractions dictionary
with open('attractions_dict3.pkl', 'wb') as f:
    pickle.dump(attractions_dict, f)
print("Attractions dictionary saved as 'attractions_dict.pkl'.")

# Train models
models = {}
for attraction_type in data['AttractionType'].unique():
    type_data = data[data['AttractionType'] == attraction_type]
    X_type = type_data[['Country', 'VisitMode', 'AttractionType']]
    y_type = type_data['Attraction']

    X_train, X_test, y_train, y_test = train_test_split(
        X_type, y_type, test_size=0.2, stratify=y_type, random_state=42
    )

    rf_model = RandomForestClassifier(random_state=42)
    rf_model.fit(X_train, y_train)
    models[attraction_type] = rf_model

    y_pred = rf_model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    attraction_type_name = label_encoders['AttractionType'].inverse_transform([attraction_type])[0]
    print(f"Test Accuracy for '{attraction_type_name}': {accuracy * 100:.2f}%")

# Save the models
with open('models3.pkl', 'wb') as f:
    pickle.dump(models, f)
print("Models saved as 'models.pkl'.")

import pandas as pd
import numpy as np
import pickle

# Load the saved models, label encoders, and attractions dictionary
with open('models3.pkl', 'rb') as f:
    models3 = pickle.load(f)

with open('label_encoders3.pkl', 'rb') as f:
    label_encoders3 = pickle.load(f)

with open('attractions_dict3.pkl', 'rb') as f:
    attractions_dict3 = pickle.load(f)

# Function to predict the top 3 attractions
def predict_top_3_attractions(country, visit_mode, attraction_type):
    """
    Predicts the top 3 attractions based on the input country, visit mode, and attraction type.
    """
    # Encode input features using the existing label encoders
    try:
        encoded_country = label_encoders3['Country'].transform([country])[0]
        encoded_visit_mode = label_encoders3['VisitMode'].transform([visit_mode])[0]
        encoded_attraction_type = label_encoders3['AttractionType'].transform([attraction_type])[0]
    except ValueError as e:
        print(f"Error in encoding: {e}")
        return []

    # Prepare input data
    input_df = pd.DataFrame([[encoded_country, encoded_visit_mode, encoded_attraction_type]],
                            columns=['Country', 'VisitMode', 'AttractionType'])

    # Get the model for the specified AttractionType
    if encoded_attraction_type not in models3:
        print("No model found for the specified AttractionType.")
        return []

    model = models3[encoded_attraction_type]
    probabilities = model.predict_proba(input_df)[0]

    # Get the classes corresponding to these probabilities
    model_classes = model.classes_

    # Get the attractions for the given AttractionType from the preprocessed dictionary
    attractions_of_type = attractions_dict3.get(encoded_attraction_type, [])

    # Map the encoded attractions to the indices in the model's classes
    relevant_indices = [np.where(model_classes == attraction)[0][0] for attraction in attractions_of_type if attraction in model_classes]

    # Extract probabilities for the relevant attractions
    relevant_probs = [probabilities[i] for i in relevant_indices]

    # Sort the relevant attractions by their probabilities in descending order
    top_3_indices = np.argsort(relevant_probs)[-3:][::-1]
    top_3_encoded_attractions = [attractions_of_type[i] for i in top_3_indices]

    # Decode the top 3 attractions to their original names
    top_3_attractions = label_encoders3['Attraction'].inverse_transform(top_3_encoded_attractions)
    return top_3_attractions

# Example usage
country = "United Kingdom"
visit_mode = "Couples"
attraction_type = "Cultural & Local Exploration"

top_3_attractions = predict_top_3_attractions(country, visit_mode, attraction_type)
print("Top-3 Attractions:", top_3_attractions)